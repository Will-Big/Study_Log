가상함수는 C++에서 다형성을 구현할 때 사용되며, 가상포인터는 가상함수 테이블을 가리킵니다. 객체가 생성될 때, 가상포인터는 해당 클래스의 가상함수 테이블을 가리키게 설정됩니다. 가상함수가 호출될 때, 가상포인터를 통해 올바른 함수를 찾아 실행합니다. 이렇게 해서 런타임 다형성이 구현됩니다.

```lua
[Base Class Object]
+------------------+
|  vptr            | ----> [Base VTable]
+------------------+       +------------------+
|  Base members    |       |   Base::func1()  |
+------------------+       +------------------+
                           |   Base::func2()  |
                           +------------------+

[Derived Class Object]
+------------------+
|  vptr            | ----> [Derived VTable]
+------------------+       +------------------+
|  Base members    |       | Derived::func1() |
+------------------+       +------------------+
|  Derived members |       | Derived::func2() |
+------------------+       +------------------+
```
- `vptr`: 가상포인터, 객체가 생성될 때 설정됩니다.
- `VTable`: 가상함수 테이블, 가상함수들의 주소를 저장합니다.

`vptr`는 객체마다 고유하며, 각 객체의 `vptr`는 해당 객체의 타입에 따른 `VTable`을 가리킵니다. 반면에 `VTable`은 클래스 당 하나만 생성되어 해당 클래스의 모든 객체에 의해 공유됩니다. 즉, 같은 클래스의 객체들은 같은 `VTable`을 사용하게 됩니다.
가상함수를 호출할 때, `vptr`를 사용해 적절한 `VTable`을 찾고, 그 테이블에서 함수의 주소를 찾아 실행합니다. 이렇게 런타임 다형성이 가능해집니다.

```cpp
// Assuming SomeFunction() is a virtual functions, this call

ptr->SomeFunction();

// will be tranformed into something like this:

(*ptr->__vptr[n])(ptr)
```
`ptr->SomeFunction();`이라는 가상함수 호출은 컴파일러에 의해 내부적으로 다른 형태로 변환됩니다. 이 변환된 형태가 `(*ptr->__vptr[n])(ptr)`입니다.

1. `ptr->__vptr`: `ptr`이 가리키는 객체의 가상포인터(`vptr`)를 의미합니다. 이 `vptr`는 해당 객체의 가상함수 테이블(VTable)을 가리킵니다.
2. `ptr->__vptr[n]`: `vptr`가 가리키는 VTable에서 `n`번째 위치에 있는 함수의 주소를 가져옵니다. `n`은 `SomeFunction()`의 VTable 내 위치입니다.
3. `(*ptr->__vptr[n])(ptr)`: `n`번째 위치에 있는 함수를 호출합니다. `ptr`는 `this` 포인터로 전달됩니다.


이렇게 하면 런타임에 적절한 함수가 호출됩니다. 이는 다형성을 구현하는 데 필수적인 메커니즘입니다.


참고자료
- https://anderberg.me/2016/06/26/c-virtual-functions/