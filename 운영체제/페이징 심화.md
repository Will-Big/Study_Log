- <span style="color:yellow">요구 페이징</span>
	- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
	- <span style="color:red">요구되는 페이지만</span> 적재하는 기법
		1. CPU가 특정 페이지에 접근하는 명령어를 실행한다
		2.  해당 페이지가 현재 메모리에 있을 경우(유효비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다
		3. 해당 페이지가 현재 메모리에 없을 경우(유효비트가 0일 경우) 페이지 폴트가 발생한다
		4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다
		5. 다시 1번을 수행한다

- <span style="color:yellow">페이지 교체 알고리즘</span>
	- 요구 페이징 기법으로 페이지들을 적재하다보면 언젠가 메모리가 가득 차게 됨
	- 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 함
	- 내보낼 페이지를 결정하는 방법이 <span style="color:red">페이지 교체 알고리즘</span>
	- 좋은 페이지 교체 알고리즘 = <span style="color:red">페이지 폴트가 적은 알고리즘</span>
		- 페이지 폴트가 발생하면 보조기억장치에 접근해야하기 때문에 성능 저하
	- FIFO 페이지 교체 알고리즘
		- 가장 단순한 방식
		- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
		- 보완책
			- <span style="color:red">2차 기회 페이지 교체 알고리즘</span>
			- 참조 비트 1 : 한번 더 기회를 주기(참조 비트 0으로 초기화 및 적재 시간을 갱신)
			- 참조 비트 0 : 내쫓기
	- 최적 페이지 교체 알고리즘
		- CPU에 의해 참조되는 횟수를 고려
		- 메모리에 오래 남아야 할 페이지는 <span style="color:red">자주 사용될 페이지</span>
		- 메모리에 없어도 될 페이지는 오랫동안 <span style="color:red">사용되지 않을 페이지</span>
		- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
			- <span style="color:red">가장 낮은 페이지 폴트율을 보장</span>하는 페이지 교체 알고리즘
			- <span style="color:red">실제 구현이 어려움</span>
			- 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주
	- LRU(Least-Recently-Used) 페이지 교체 알고리즘
		- 최적 페이지 교체 알고리즘 : 가장 오래 사용되지 않을 페이지 교체
		- LRU 페이지 교체 알고리즘 : 가장 오래 사용되지 않은 페이지 교체
			- 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 가정

- <span style="color:yellow">스래싱과 프레임 할당</span>
	- 페이지 폴트가 자주 발생하는 이유
		- 나쁜 페이지 교체 알고리즘을 사용해서
		- <span style="color:red">프로세스가 사용할 수 있는 프레임 자체가 적어서</span>
	- 스래싱
		- 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제
		- 동시 실행되는 프로세스 수를 늘린다고 CPU 이용률이 높아지는 것이 아니다
			- 특정 멀티프로그래밍 정도를 넘어가면 오히려 CPU 이용률이 감소함
			- 각 프로세스가 필요로하는 최소한의 프레임 수가 보장되지 않았기 때문
			- <span style="color:red">각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 한다</span>
	- 균등 할당(equal allocation)
		- 가장 단순한 할당 방식
		- 모든 프로세스들에게 균등하게 프레임을 할당하는 방식
	- 비례 할당(proportional allocation)
		- 프로세스의 크기를 고려하자
		- 프로세스 크기에 비례하여 프레임 할당
		- 하지만 프로세스 크기와는 별개로 프레임을 요구하는 정도는 다를 수 있기 때문에 <span style="color:red">실행해봐야 알 수 있음</span>
	- 작업 집합 모델
		- 프로세스가 실행하는 과정에서 배분할 프레임 결정
		- 스래싱이 발생하는 이유는 빈번한 페이지 교체가 원인
			- 이를 해결하기 위해 <span style="color:red">CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임을 할당</span>하기
		- 작업 집합을 구하려면 필요한 것
			1. 프로세스가 참조한 페이지
			2. 시간 간격
	- 페이지 폴트 빈도
		 - 프로세스가 실행하는 과정에서 배분할 프레임 결정
		 - 두 개의 가정에서 생겨난 아이디어
			 - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 가지고 있음
			 - 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 가지고 있음
		- 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식

- <span style="color:yellow">쓰기 시 복사</span>
	- 이론적인 fork()
		- 프로세스는 기본적으로 자원을 공유하지 않는다 -> 부모 프로세스가 적재된 별도의 공간에 자식 프로세스가 통째로 복제되어 적재(프로세스 생성 시간 지연, 메모리 낭비
	- 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면 자식 프로세스는 부모 프로세스와 <span style="color:red">동일한 프레임</span>을 가리킴(쓰기 작업 없다면 이 상태를 유지)
	- 부모 프로세스/자식 프로세스 둘 중 하나가 페이지에 쓰기 작업 수행 시 해당 페이지는 별도의 공간으로 복제(프로세스 생성 시간 절약, 메모리 절약)

- <span style="color:yellow">계층적 페이징</span>
	- 프로세스 테이블의 크기는 생각보다 작지 않음
	- 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 낭비
	- 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 방법
	- <span style="color:red">페이지 테이블을 페이징</span>하여 여러 단계의 페이지를 두는 방식
		- 계층적 페이징을 이용하는 환경에서의 논리 주소
			- 바깥 페이지 번호, 안쪽 페이지 번호, 변위