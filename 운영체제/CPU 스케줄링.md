<span style="color:yellow">CPU 스케줄링이란?</span>
- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 분배하는 것

<span style="color:yellow">프로세스 우선순위(Priority)</span>
- 가장 공정한 CPU 스케줄링?
	- 다양한 방법이 있으며 사용자가 정해주거나, 운영체제가 결정함
	- e.g. 입출력 작업이 많은 프로세스(=입출력 집중 프로세스)의 우선순위는 CPU 작업이 많은 프로세스 (=CPU 집중 프로세스)의 우선순위보다 높다
- 스케줄링 큐
	- 운영체제가 PCB를 확인해가며 프로세스가 필요로 하는 자원을 제공하는 것은 비효율적
	- 자원을 이용하고 싶어하는 프로세스들이 서는 줄
		- 반드시 선입선출 방식일 필요는 없음
	- 준비 큐
		- CPU를 이용하고자 하는 프로세스들(준비상태)이 서는 줄
	- 대기 큐
		- 입출력 장치를 이용하고자 하는 프로세스들(대기상태)이 서는 줄
		- 같은 장치를 요구한 프로세스들은 같은 큐에서 대기
	- ![[Pasted image 20230922191702.png]]
	- 선점형 스케줄링(preemptive scheduling)
		- 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
			- 장점 : 어느 한 프로세스의 자원 독점을 막고 프로세스들에  골고루 자원을 배분할 수 있다
			- 단점 : 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다
	- 비선점형 스케줄링(non-preemptive scheduling)
		- 현재 CPU를 사용 중인 프로세스의 작업이 끝날 때 까지 프로세스 기다리기
			- 장점 : 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
			- 단점 : 모든 프로세스가 골고루 자원을 이용하기 어렵다



<span style="color:yellow">CPU 스케줄링 알고리즘</span>
- 선입 선처리
	- FCFS(First Come First Served) 스케줄링
	- 단순히 <span style="color:red">준비 큐에 삽입된 순서대로</span> 처리하는 비선점 스케줄링
	- 먼저 CPU를 요청한 프로세스부터 CPU 할당
	- 단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용 (=호위 효과)
- 최단 작업 우선
	- SJF(Shortest Job First) 스케줄링
	- CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
	- <span style="color:red">CPU 사용 시간이 가장 짧은 프로세스부터 처리</span> 하는 스케줄링 방식
	- 라운드 로빈
	- RR(Round Robin) 스케줄링
	- 선입 선처리 스케줄링 +  <span style="color:red">타임 슬라이스(time slice)</span>
	- 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
	- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
		- 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용
		- 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입 (문맥교환)
- 최소 잔여 시간 우선
	- SRT(Shortest Remaining Time) 스케줄링
	- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
	- 최단 작업 우선 스케줄링 : 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘
	- 라운드 로빈 스케줄링 : 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
	-  <span style="color:red">정해진 시간만큼 CPU를 이용</span>하되, 다음으로 CPU를 사용할 프로세스로는  <span style="color:red">남은 작업 시간이 가장 적은 프로세스</span> 선택
- 우선순위
	- 프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
	- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
	- 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 **⊂** 우선순위 스케줄링
		- 우선순위 스케줄링의 근본적인 문제점,  <span style="color:red">기아(starvation)</span> 현상
		- 우선순위 높은 프로세스만 실행
		- 우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기
			- 이를 방지하기 위한 기법 : 에이징(aging)
			- 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
			- 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법
				- 우선순위가 낮아도 언젠가는 우선순위가 높아진다
- 다단계 큐
	- Multilevel Queue 스케줄링
	- 우선순위 스케줄링의 발전된 형태
	- 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
		- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
		- 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리
	- 큐 간에 이동이 불가능하기 때문에 기아 현상이 발생할 수 있음
- 다단계 피드백 큐
	- Multilevel Feedback Queue 스케줄링
	- 다단계 큐 스케줄링의 발전된 형태
		1. 새롭게 준비 상태가 된 프로세스를 가장 우선순위가 높은 큐에 삽입
		2. 일정시간(Time Slice)만큼 CPU를 할당하여 사용하도록 함
		3. 다음 우선순위에 해당하는 큐에 삽입
	- 큐 간의 이동이 가능한 다단계 큐 스케줄링
	- 다단계 큐 스케줄링에서는 기본적으로 큐 간의 이동 불가
		- 우선순위 낮은 프로세스는 계속해서 실행 연기 우려
		- 기아 현상 발생 가능
	- CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐
	- ![[Pasted image 20231010112954.png]]


