- <span style="color:yellow">스와핑</span>
	- 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역으로 쫓아내고 그렇게 생긴 빈 공간에 새 프로세스를 적재함
	- 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기
- <span style="color:yellow">메모리 할당</span>
	- 프로세스는 메모리의 빈 공간에 할당되어야 한다
	- 빈 공간이 여러개 있을 경우
		- 최초 적합(first-fit)
			- 운영체제가 메모리 내의 빈 공간을 순선대로 검색하다 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
			- 검색 최소화, 빠른 할
		- 최적 적합(best-fit)
			- 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당
		- 최악 적합(worst-fit)
			- 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당
- <span style="color:yellow">외부 단편화</span>
	- 프로세스를 연속적으로 메모리에 할당하는 방식 -> 외부 단편화 문제 발생
		- 외부 단편화 : 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
	- 프로세스들이 실행되고 종료되길 반복하며 메모리 사이 사이에 빈 공간 발생
	- 해결
		- 메모리 압축(compaction)
			- 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
			- 프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
		- 가상 메모리 기법, 페이징
			- 실행하고자 하는 프로그램을 일부만 메모리에 적재 -> 실제 물리 메모리 크기보다 큰 프로세스를 실행할 수 있게 하는 기술
- <span style="color:yellow">페이징(paging)이란</span>
	- 외부 단편화가 발생했던 근본적인 문제를 해결할 수 있는 기술
	- 프로세스를 일정 크기로 자르고 메모리에 불연속적으로 할당
		1. 프로세스의 <span style="color:red">논리 주소 공간을 페이지(page)</span> 라는 일정 단위로 자르고
		2. 메모리의 <span style="color:red">물리 주소 공간을 프레임(frame)</span> 이라는 페이지와 동일한 일정한 단위로 자른 뒤
		3. 페이지를 프레임에 할당하는 가상 메모리 관리 기법
	- 페이징에서의 스와핑
		- 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)
		- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
		- 실행에 필요한 페이지들은 메모리로 스왑 인
			- 프로세스를 실행하기 위해 모든 페이지가 적재될 필요는 없음 -> 물리 메모리보다 큰 프로세스도 실행 가능
- <span style="color:yellow">페이지 테이블</span>
	- 페이지 테이블의 필요성
		- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기 어려움
		- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없음
		- CPU 입장에서 '다음에 실행할 명령어 위치' 를 찾기가 어려워짐
	- 물리 주소에 불연속적으로 배치되더라도 논리 주소상에서 연속적으로 배치되도록 하는 방법
	- <span style="color:red">페이지 번호와 프레임 번호를 짝지어 주는  일종의 이정표</span>
	- 프로세스마다 페이지 테이블을 가지고 있음
	- 내부 단편화
		- 프로세스의 크기보다 큰 메모리가 할당된 경우에 나타나는 문제
		- 단일 페이지의 크기보다 작은 크기로 발생할 수 있음
- <span style="color:yellow">PTBR</span>
	- 프로세스마다 페이지 테이블이 존재함
	- 각 페이지 테이블은 CPU  내의 <span style="color:red">프로세스 테이블 베이스 레지스터(PTBR)</span> 가 가리킴
- <span style="color:yellow">TLB</span>
	- CPU 곁의 페이지 테이블 캐시 메모리
	- 페이지 테이블의 일부를 가져와 저장
	- CPU 가 접근하려는 논리 주소가 TLB 에 있을 경우 : TLB 히트
	- CPU 가 접근하려는 논리 주소가 TLB 에 없을 경우 : TLB 미스
- <span style="color:yellow">페이징에서의 주소 변환</span>
	- 특정 주소에 접근하려면 필요한 정보
		- 접근하려는 페이지/프레임
		- 페이지/프레임 내의 접근하려는 주소 오프셋
	- 페이징 시스템에서의 논리 주소
		- 페이지 번호(page number)와 변위(offset)
			- <페이지 번호와 변위> 로 이루어진 논리 주소는 페이지 테이블을 통해 <프레임 번호와 변위> 로 변환됨
- <span style="color:yellow">페이지 테이블 엔트리</span>
	- 페이지 테이블의 각각의 행 : 페이지 테이블 엔트리(PTE)
		- 페이지 번호, 프레임 번호
		- 유효 비트 : 현재 페이지에 접근 가능한지 여부
			- 유효 비트가 0인 페이지에 접근하면
				- 페이지 폴트(page fault)라는 인터럽트 발생
					1. CPU는 기존 작업 내역을 백업
					2. 페이지 폴트 처리 루틴을 실행
					3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가졍노 뒤 유효 비트를 1로 변경
					4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있게 됨
		- 보호 비트 : 페이지 보호 기능을 위해 존재하는 비트
			- 페이지에 접근할 권한(읽기/쓰기/실행)을 제한하여 페이지를 보호하는 비트
		- 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 여부
		- 수정 비트(=dirty bit) : CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
			- 수정 비트의 존재 이유 : 수정된 페이지를 확인하여 보조기억장치에 쓰기 작업이 필요한 메모리만 적절하게 하기 위해서