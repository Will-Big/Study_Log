
- <span style="color:yellow">명령어의 구조</span>
	- 명령어는 연산 코드와 오퍼랜드로 구성됨
		- 연산 코드
			- 수행할 연산
				- 데이터 전송
					- MOVE : 데이터를 옮겨라
					- STORE : 메모리에 저장하라
					- LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라
					- PUSH : 스택에 데이터를 저장하라
					- POP : 스택의 최상단 데이터를 가져와라
				- 산술/논리 연산
					- ADD / SUBTRACT / MULTIPLY / DIVIDE
					- INCREMENT / DECREMENT
					- AND / OR / NOT
					- COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
				- 제어 흐름 변경
					- JUMP : 특정 주소로 실행 순서를 옮겨라
					- CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
					- HALT : 프로그램 실행을 멈춰라
					- CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
					- RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
				- 입출력 제어
					- READ / WRITE
					- START IO : 입출력 장치를 시작하라
					- TEST IO :  입출력 장치의 상태를 확인하라
		- 오퍼랜드
			- 연산에 사용될 데이터 혹은 연산에 사용될 데이터가 저장된 위치
				- 연산에 사용될 데이터가 저장된 위치가 훨씬 자주 저장
				- 이를 <span style="color:red">주소 필드</span>로 칭하기도 함
			- 오퍼랜드는 없을 수도 있고 하나 이상인 경우도 있음
			- <span style="color:yellow"></span><span style="color:red">굳이 위치를 저장하는 이유?</span>
				- 명령어 내에서 표현할 수 있는 데이터의 크기가 제한되기 때문
				- ![[Pasted image 20231004160911.png]]

- <span style="color:yellow">명령어 주소 지정 방식</span>
	- 유효 주소(effective address) 
		- 연산에 사용할 데이터가 저장된 위치 (위 상황에서는 10번지)
	- 명령어 주소 지정 방식(addressing modes)
		- 연산에 사용할 데이터가 저장된 위치를 찾는 방법
		- 유효 주소를 찾는 방법
		- 다양한 명령어 주소 지정 방식
			- 즉시 주소 지정 방식(immediate addressing mode)
				- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
				- 가장 간단한 형태의 주소 지정 방식
				- 연산에 사용할 데이터의 크기가 작아질 수 있지만, 빠름
			- 직접 주소 지정 방식(direct addressing mode)
				- 오퍼랜드 필드에 유효 주소 직접적으로 명시
				- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦
			- 간접 주소 지정 방식(indirect addressing mode)
				- 오퍼랜드 필드에 유효 주소의 주소를 명시
				- 앞선 주소 지정 방식들에 비해 속도가 느림
			- 레지스터 주소 지정 방식(register addressing mode)
				- 연산에 사용할 데이터가 저장된 레지스터 명시
				- 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름
			- 레지스터 간접 주소 지정 방식(register indirect addressing mode)
				- 연산에 사용할 데이터를 메모리에 저장
				- 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
